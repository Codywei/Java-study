# Java 基础知识

标签（空格分隔）： Java基础

---

<h2>1.面向对象和面向过程的区别（性能or封装)</h2>
(1)面向过程</br>         
优点：性能比面向对象高，因为类调用时需要实例化(封装的代价)，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。（底层调用-C语言）</br>
缺点：没有面向对象易维护、易复用、易扩展</br>
(2)面向对象</br>
优点：易维护、易复用、易扩展，由于面向对象有封装（维护）、继承（复用）、多态性（扩展）的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护（JavaWeb项目-Java语言）</br>
缺点：性能比面向过程低</br>

<h2>2.Java的四个基本特性（抽象、封装、继承，多态）</h2>
抽象：</br>
　　就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。</br>
　　抽象包括两个方面：一个是数据抽象，一个是过程抽象。</br>
　　数据抽象也就是对象的属性。过程抽象是对象的行为特征。</br>
封装：</br>
　　把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。（public，private，protected）</br>
　　封装分为属性的封装和方法的封装。（类和接口）</br>
继承：</br>
　　是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。父类的意义在于抽取多类事物的共性。</br>
多态：</br>
　　允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。</br>

<h2>3.重载和重写的区别</h2>

重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</br>
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写（无法继承）。</br>

<h2>4.构造器Constructor是否可被override</h2>
构造器不能被重写，不能用static修饰构造器，只能用public，private，protected这三个权限修饰符，且不能有返回语句。（构造器用于产生实例，每一个类必须有自己的构造函数，负责构造自己这部分的构造子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数），“不能用static修饰构造器”这个说法有待商榷，这一部分可以看一下这个链接http://www.cnblogs.com/JackieYang/archive/2010/02/23/1671724.html</br>

<h2>5.访问控制符public,protected,private,以及默认的区别</h2>
private只有在本类中才能访问；</br>
public在任何地方都能访问；</br>
protected在同包内的类及包外的子类能访问；</br>
默认不写在同包内能访问。</br>


<h2>6.是否可以继承String类</h2>
String类是final类故不可以继承，一切由final修饰过的都不能继承。

<h2>7.String和StringBuffer、StringBuilder的区别</h2>
（1）可变性</br>
String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。
StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。</br>
（2）线程安全性</br>
String中的对象是不可变的，也就可以理解为常量，线程安全。</br>
AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</br>
StringBuffer对方法加了**同步锁**或者对调用的方法加了同步锁，所以是线程安全的。</br>
StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</br>
（3）性能</br>
每次对String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。
StringBuffer每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</br>
相同情况下使用 StirngBuilder 相比使用StringBuffer 仅能获得10%~15%左右的性能提升，但却要冒多
线程不安全的风险。</br>

<h2>8.hashCode和equals方法的关系</h2>
equals相等，hashcode必相等；hashcode相等，equals可能不相等。


<h2>9.抽象类和接口的区别</h2>
语法层次</br>
抽象类和接口分别给出了不同的语法定义。</br>
设计层次</br>
抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</br>
跨域不同</br>
抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a"关系，即父类和派
生类在概念本质上应该是相同的。</br>
对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，"like-a"的关系。</br>

<h2>10.自动装箱与拆箱</h2>
装箱：将基本类型用它们对应的引用类型包装起来；</br>
拆箱：将包装类型转换为基本数据类型；</br>
Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</br>


<h2>11.什么是泛型、为什么要使用以及泛型擦除</h2>

泛型，即“参数化类型”。</br>
创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。</br>
Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。</br>
类型擦除的主要过程如下：</br>
1）.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</br>
2）.移除所有的类型参数。</br>

<h2>12.Java中的集合类及关系图</h2>
List和Set继承自Collection接口。</br></br>
Set无序不允许元素重复。HashSet和TreeSet是两个主要的实现类。</br>
List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。</br>
Map也属于集合系统，但和Collection接口没关系。Map是key对value的映射集合，其中key列就是一个集合。key不能重复，但是value可以重复。HashMap、TreeMap和Hashtable是三个主要的实现类。</br>
SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序.</br>



