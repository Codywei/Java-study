# Java并发编程（一）

标签（空格分隔）： java 并发编程

---
<h1>第一章  简介</h1>

<h2>1.引入多程序同时执行原因</h2>
（1）资源利用率 ：由单核提升到多核</br>
（2）公平性：解决用户独占   </br>
（3）便利性：分工合作更容易实现</br>


<h2>2.线程的优势</h2>
（1）发挥多处理器的强大能力</br>
（2）建模的简单性   </br>
（3）异步事件的简化处理</br>
（4）灵敏的用户响应界面</br>


<h2>3.线程带来的风险</h2>
（1）安全性问题：竞态条件</br>
（2）活跃性问题：死锁，饥饿，活锁   </br>
（3）性能问题</br>


<h2>4.框架引入并发性</h2>
框架通过在框架线程中调用应用程序代码将并发性引入到程序中。在代码中将不可避免地访问应用程序状态，因此所有访问这些状态的代码路径都必须是线程安全的。（TIMER，Servlet（JavServer Page）,RMI,Swing(AWT)）




<h1>第二章  线程安全性</h1>

<h2>1.修复访问状态变量线程安全性</h2>
如果多个线程访问同一个可变的状态变量时没用使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题： </br>
（1）不在线程之间共享该状态变量 </br>
（2）将状态变量修改为不可变的变量 </br>
（3）在访问状态变量时使用同步</br>

完全由线程安全类构造的程序也不一定是线程安全的，线程安全类中也可以包含非线程安全的类.

<h2>2.线程安全性定义</h2>
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。


<h2>3.无状态对象</h2>
无状态对象一定是线程安全的。无状态类是指不包含任何域或也没有引用其它类的域。一次特定计算的瞬间状态，会唯一存在本地变量中。只有无状态对象（例：servlet）在处理请求时需要保存一些信息时，线程安全性才会成为一个问题。



<h2>4.竞态条件</h2>
在并发编程中，由于不恰当的执行时序而出现不正确的结果，成为竞态条件。 </br>

类型：1.延迟初始化  2.读取-修改-写入 3.复合操作 </br>



<h2>5.线程管理对象</h2>
在实际情况中，应尽可能使用线程安全对象来管理类的状态（有助于维护和验证线程安全性）。


<h2>6.内置锁</h2>
Java内置锁机制：同步代码块（Syschronized Block） </br>
synchronized(lock){访问或修改共享变量}</br>
synchronized方法为保证整个方法体为原子的，lock为this</br>
非静态类 ：锁的是类实例 </br>
静态类：锁的是class对象 </br>

最多只有一个对象持有该锁，进入同步代码块获得锁，出代码块释放锁</br>
synchronized特性不能被继承，即覆盖方法需要也写synchronized关键字</br>


<h2>7.重入</h2>
获取锁操作的粒度是“线程”而非“调用”。 </br>
重入的一种实现方法是为每一个锁关联一个计数器和一个所有者线程。 </br>


<h2>8.状态变量</h2>
对于可能被多个线程访问的可变状态变量，在访问它时都需要持有同一个锁（不只是写入的时候，因为涉及可见性的问题）。在这种情况下，我们称状态变量是由这个锁保护的。


<h2>9.线程安全性与性能</h2>
当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制I/O）,一定不要持有锁。





<h1>第三章  内存可见性</h1>

<h2>1.重排序</h2>
在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行意想不到的调整。 </br>


<h2>2.失效数据</h2>
在缺少同步的程序中产生错误的结果的一种情况（一般为程序在之前运行过程中产生的过时数据）。造成程序的不确定性。 </br>

<h2>3.非原子的64位操作</h2>
即使是失效数据也是程序过去运行中产生的数据。 </br>

但执行非原子的64位操作，JVM会分解为两个32位操作，从而可能造成错误的值。使用volatile关键字解决。 </br>


<h2>4.加锁与可见性</h2>
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。 </br>

<h2>5.volatile变量</h2>
加锁机制及可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。 </br>
当且仅当满足下列所有条件时，才应该使用volatile变量： </br>
（1）对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。 </br>
（2）该变量不会与其他状态变量一起纳入不变性条件 。 </br>
（3）在访问变量时不需要加锁。 </br>


<h2>6.发布与逸出</h2>
发布：是对象能够在当前作用域之外的代码中使用 </br>
逸出：某个不应该发布的对象被发布（如果在对象构造完成之前就发布该对象，就会破坏线程安全性） </br>



<h2>7.外部方法</h2>
外部方法：其他类中定义的方法，类中可以被改写的方法（不为private也不为final）


<h2>8.构造过程中逸出</h2>
（1）发布内部类实例导致this引用逸出 </br>
（2）在构造函数中创建线程导致this引用逸出 </br>
（3）在构造函数中调用一个可改写的实例方法导致this引用逸出 </br>


<h2>9.线程封闭</h2>
（1）AD-hoc线程封闭：维护线程封闭性的职责完全有程序实现来承担（少用） </br>
（2）栈封闭：在栈封闭中，只能通过局部变量才能访问对象。 </br>
（3）ThreadLocal类：用于防止对可变的单实例变量或全局变量进行共享。 </br>


<h2>10.不变性</h2>
不可变对象一定是线程安全的。 </br>
当满足以下条件时，对象才是不能修改的： </br>
（1）对象创建后其状态是不可改变的 </br>
（2）对象的所有域都是final类型 </br>
（3）对象是正确创建的（在创建对象过程中，this引用没有逸出） </br>

在不可变对象内部仍可以使用可变对象管理他们的状态。 </br>


对象创建出来后无论如何对此对象进行非暴力操作（不用反射），此对象的状态（实例域的值）都不会发生变化，那么此对象就是不可变的，相应类就是不可变类，跟是否用 final 修饰没关系。
（例：final域中保存了可变对象的引用）



<h2>11.Final域</h2>
Final域还有着特殊的语义。Final域能确保初始化过程中安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。



<h2>12.安全发布对象的常用模式</h2>
要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全的发布： </br>
（1）在静态初始化函数中初始化一个对象的引用 </br>
（2）将对象的引用保存到到volatile类型的域或者AtomicReferance对象中 </br>
（3）将对象的引用保存到某个正确构造对象的final类型域中 </br>
（4）将对象的引用保存到一个有锁保护的域中 </br>




<h2>13.对象发布需求</h2>
对象发布需求取决于它的可变性： </br>
（1）不可变对象可以通过任意机制来发布 </br>
（2）事实不可变对象必须通过安全方式来发布 </br>
（3）可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。 </br>



<h2>14.使用和共享对象的实时策略</h2>
（1）线程封闭 </br>
（2）只读共享 </br>
（3）线程安全共享（对象在内部实现同步） </br>
（4）保护对象（被保护的对象只能通过特定的锁访问） </br>





<h1>第四章  对象的组合</h1>


<h2>1.设计线程安全的类</h2>
（1）找出构成对象状态的所有变量</br>
（2）找出约束状态变量的不变性条件</br>
（3）建立对象状态的并发访问管理策略</br>

1、收集同步需求（找出复合操作、多个变量遵循原子性的操作等）</br>
2、依赖状态的操作（找出操作是否基于先验条件，例：取出当队列不为空）</br>
3、状态的所有权（对象被哪些线程所有，哪些线程可以操作对象）</br>

<h2>2.实例封闭（Java监视器模式）</h2>
将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

Java监视器模式：把对象的所有可变状态封装起来，并使用对象的内置锁保护</br>

使用私有锁而不是内置锁的优点：（private final Object myLock = new Object();） </br>
（1）私有锁可以将锁封装起来，客户代码无法得到锁。</br>
（2）客户可以通过公有方法来访问锁，以便参与到同步策略中去。</br>



<h2>3.线程安全性委托</h2>
如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。

1、委托给单个线程安全状态变量可以保证线程安全性</br>

2、委托给多个相互独立的线程安全状态变量可以保证线程安全性</br>

3、如果类包含多个线程安全状态变量的符合操作，则无法保证线程安全性，可以通过加锁机制保证</br>

4、发布：如果一个状态变量是线程安全的，并且没有不变性条件约束它（例：大于0），在变量操作上没有不允许的状态转换，则可以安全发布</br>

5、安全发布底层状态的线程安全类</br>


<h2>4.现有的线程安全类添加功能</h2>
（1）客户端加锁机制
使用某个对象的代码时必须使用该对象本身用于保护其状态的锁，不推荐（同步的实现被分布到不相关的类中）</br>
（2）组合
操作委托给底层的实例来操作，并通过自身的内置锁增加一层额外的加锁，同时添加了新的同步方法。
</br>



<h1>第五章  基础构建模块</h1>

委托是创建线程安全类的一个最有效的策略：只需让现有的线程安全类管理所有的状态即可。</br>

<h2>1.同步容器类的问题</h2>
（1）同步容器类都是线程安全的，容器本身内置的复合操作能够保证原子性，但是当在其上进行客户端复合操作则需要额外加锁保护其安全性</br>
（2）由于同步容器类要遵守同步策略，即支持客户端加锁，但必须清楚加入同一个锁</br>


<h2>2.迭代器与ConcurrentModificationException</h2>
（1）及时失败机制：容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException异常
</br>
     解决方法：加锁或创建副本</br>

<h2>3.隐藏迭代器</h2>
一些隐藏的迭代操作：hashCode, equals, containsAll, removeAll, retainAll等


<h2>4.并发容器</h2>
同步容器对容器状态访问实现串行化以保证线程安全，但这种方法严重降低了并发性。通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。</br>

BlockingQueue扩展了Queue，实现了可阻塞的插入和获取等操作ConcurrentHashMap代替HashMap</br>


（1）ConcurrentHashMap</br>

　　并不是在每个方法上都在锁使得只有一个线程可以访问容器，即没有实现独占访问。而是使用一种粒度更细的加锁机制来实现大程度的共享，这种机制称为分段锁(Lock Striping)</br>

　　ConcurrentHashMap的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中加锁，因为其返回的迭代器具有弱一致性，而非"及时失败"。</br>

　　ConcurrentHashMap对一些操作进行了弱化，如size(计算的是近似值，而不是精确值)， isEmpty等</br>
　　

（2）额外的原子Map操作</br>

　　ConcurrentHashMap实现了若没有则添加、若有则删除、映射则替换等操作的接口</br>
　　
　　
（3）CopyOnWriteArrayList</br>

　　特点：写入时复制，即每当修改容器时都会复制底层数组产生开销，只要发布一个事实不可变的对象，那么在访问该对象时就不需要进一步同步</br>

　　不会抛出ConcurrentModificationException，不用加锁，性能更好</br>

　　仅当迭代操作远远多于修改操作时，才应该使用"写入时复制"容器</br>
　　
　　
　　
<h2>5.阻塞队列和生产者消费者模式</h2>
阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。（offer方法如果数据不能添加到队列则返回一个失败状态）</br>

可有界也可无界:在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具；它们能够意志或防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。</br>

实现：</br>
LinkedBlockingQueue， ArrayBlockingQueue，PriorityBlockingQueue（可实现comparable方法比较排序），SynchronousQueue（维护一组工作线程，而不是维护队列元素的存储空间。当且仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列）</br>




<h2>6.串行线程封闭</h2>
     对于可变对象，生产者--消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。</br>

　　线程封闭对象由单个线程所有，但通过生产者消费者模式安全的转移了对象的所有权，转移后只有接受的线程获得该对象的所有权，而发布者放弃了所有权，并不会在访问他。</br>


<h2>7.双端队列适用于工作密取</h2>
Deque和BlockingDeque对Queue进行了拓展，实现了双端队列，即从头尾皆可插入删除。（实现：ArrayDeque，LinkedBlockingDeque）。</br>

　　每个消费者有各自的双端队列，当消费者自己的双端队列为空时，它会从其他消费者队列末尾中密取任务。优点：大大减少了竞争，保证线程均出于忙碌状态。</br>
　　
　　

<h2>8.阻塞方法和中断方法</h2>
阻塞的原因：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep方法中醒来，或是等待另一个线程的计算结果等线程阻塞时会被挂起，处于某种阻塞状态（BLOCKED，WAITING，TIMED_WAITING），并且必须等待某个不受他控制的事件完成。</br>

抛出InterruptedException的方法叫做阻塞方法</br>

中断是一种协作机制，一个线程不能强制要求其他线程停止正在执行的操作而去执行其他操作。</br>

处理对中断的响应：传递InterreuptedException，抛出异常给方法调用者，或捕获异常，做一些清理工作再抛出抛出异常；恢复中断：有时不能抛出InterruptedException, 比如在Runnable中，则可以恢复中断。
</br>




<h2>9.同步工具类</h2>
（1）闭锁：确保某些活动直到其他活动都完成后才继续执行</br>
闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态。</br>

　　CountDownLatch：一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法阻塞直到计数器到达零.</br>
　　
(2)FutureTask</br>
    FutureTask是通过 Callable来实现的，相当于一种可生成结果的Runnable，并且可处于以下三种状态：等待运行，正在运行，运行完成（正常完成、取消、异常结束）。当FutureTask进入完成状态后，它会停留在这个状态上。</br>

　　Future.get 用来获取计算结果，如果FutureTask还未运行完成，则会阻塞。FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。</br>
　　
(3)信号量</br>
计数信号量用来控制同时访问某个特定资源的操作数量，或同时执行某个指定操作的数量。或者可以用来实现某种资源池，或者对容器施加边界。</br>

Semaphore管理一组虚拟许可，有构造函数指定数量（数量为1即为互斥锁），acquire请求许可（阻塞直到获得，或中断，或超时），release释放一个许可</br>

(3)栅栏</br>

栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。</br>

闭锁用于等待事件，而栅栏用于等待其他线程。闭锁是一次性对象，一旦进入终止状态，就不能被重置。</br>



<h2>10.构建高效可伸缩的结果缓存</h2>

（1）首先考虑采用HashMap，通过sychronized方法满足原子性但是性能较差，同一时间只有一个线程进行计算操作。</br>
（2）使用ConcurrentHashMap改善性能，无需使用同步方法，但是可能导致很多线程在计算同样的值</br>
（3）考虑阻塞方法，使用基于FutureTask的ConcurrentHashMap，Future.get实现阻塞知道结果返回，减少了多次计算，但仍然不是原子性的</br>
（4）使用ConcurrentHashMap中的 putifAbsent()</br>
（5）继续解决缓存污染问题，当缓存结果失效时移除，解决缓存逾期，缓存清理等等问题。</br>
