# Java多线程

标签（空格分隔）： Java 多线程

---
    这一部分的有些内容有在java-concurrent做了小练习
<h2>1.多线程的实现方式</h2>
继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。
链接：https://www.cnblogs.com/wxd0108/p/5479442.html


<h2>2.多线程的状态切换</h2>
![此处输入图片的描述][1]


  [1]: http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg
  
Java中的线程的生命周期大体可分为5种状态。
1. 新建(NEW)：新创建了一个线程对象。</br>
2. 可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</br>
3. 运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</br>
4. 阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：</br> 
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</br>
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</br>
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</br>
5. 死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</br>

链接：http://blog.csdn.net/pange1991/article/details/53860651

<h2>3.如何停止一个线程</h2>
1.Thread.stop()(不建议，有可能造成数据不一致)</br>
2.interrupt配合异常处理</br>
3.interrupt配合return</br>
4.this.interrupted(): 测试当前线程是否已经中断，再执行一次就把标志位还原</br>
  this.isInterrupted(): 测试线程是否已经中断；</br>

参考链接：http://www.cnblogs.com/greta/p/5624839.html



<h2>4.什么是线程安全，如何保障线程安全</h2>
线程安全就是多线程访问同一代码，不会产生不确定的结果。</br>
保障线程安全：</br>
对非安全的代码进行加锁控制；</br>
使用线程安全的类；</br>
多线程并发情况下，线程共享的变量改为方法级的局部变量。</br>


<h2>5.synchronized如何使用</h2>
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</br>
（1). 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</br>
（2). 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</br>
（3). 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</br>
（4). 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</br>


<h2>6.synchronized和Lock的区别</h2>
主要相同点：Lock能完成synchronized所实现的所有功能。</br>
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。Lock的锁定是通过代码实现的，而synchronized是在JVM层面上实现的，synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</br>
Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。Lock锁的范围有局限性，只作用于块范围，而synchronized可以锁住块、对象、类。</br>

<h2>7.多线程如何进行信息交互</h2>
void notify() 唤醒在此对象监视器上等待的单个线程。</br>
void notifyAll() 唤醒在此对象监视器上等待的所有线程。</br>
void wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法。</br>
void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。</br>
void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</br>


<h2>8.sleep和wait的区别(考察的方向是是否会释放锁)</h2>
sleep()方法是Thread类中方法，而wait()方法是Object类中的方法。</br>
sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。


<h2>9.多线程与死锁</h2>
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</br>
产生死锁的原因：</br>
一.因为系统资源不足。</br>
二.进程运行推进的顺序不合适。</br>
三.资源分配不当。</br>


<h2>10.死锁的产生</h2>
产生死锁的四个必要条件：</br>
一.互斥条件：所谓互斥就是进程在某一时间内独占资源。</br>
二.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</br>
三.不剥夺条件:进程已获得资源，在未使用完之前，不能强行剥夺。</br>
四.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系</br>


<h2>11.死锁的预防</h2>
打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</br>
一.打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。</br>
二.打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</br>
三.打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</br>
四.打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。</br>


<h2>12.什么叫守护线程，用什么方法实现守护线程</h2>
守护线程是为其他线程的运行提供服务的线程。</br>
setDaemon(boolean on)方法可以方便的设置线程的Daemon模式，true为守护模式，false为用户模式</br>





