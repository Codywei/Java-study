# Java并发编程（二）

标签（空格分隔）： java 并发编程

---
<h1>第六章  任务执行</h1>

<h2>1.在线程中执行任务</h2>
任务的独立性：任务并不依赖于其他任务的状态，结果和边缘效应。独立的任务可以实现并行执行。</br>

（1）串行的执行任务</br>

所有的任务放在单个线程中串行执行，程序简单，安全性高，不涉及同步等情况，缺点也显而易见，无法提高吞吐量和响应速度，适合任务数量很少并且执行时间很长时，或者只为单个用户使用，并且该用户每次只发出一个请求。</br>

（2）显式的创建线程</br>

为每一个请求创建一个线程，将任务的处理从主线程中分离出来，多个任务可以并行处理，充分利用了系统资源，提高吞吐量和相应速度，要求处理代码必须是线程安全的。</br>

（3）无限创建线程的不足</br>

线程生命周期的开销非常高；太多线程会消耗系统资源，空闲线程的内存空间占用，大量线程竞争CPU时产生其他性能开销；稳定性：破坏这些限制底层操作系统对线程的限制很可能抛出OutOfMemoryError异常。</br>

总结：在一定范围内，增加线程有助于提高吞吐量，但是再多就可能导致性能下降。</br>

<h2>2.Executor框架</h2>
（1）Executor简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池作为Executor框架的一部分。</br>

（2）Executor基于生产者—消费者设计模式，提交任务的操作单元相当于生产者（生成待完成的工作单元），执行任务的线程相当于消费者（执行完这些工作单元。）</br>

（3）将提交过程和执行过程解耦，用Runnable表示执行任务。</br>


（4）线程池：管理一组同构工作线程的资源池。</br>

线程池vs工作队列：工作者线程来自线程池，从工作队列获取任务，执行完毕回到线程池。</br>

优点：不仅可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销，另外一个好处就是当请求到达时，工作线程通常已经存在，因此不会由于等待线程创建而延迟任务的执行。</br>

newFixedThreadPool:固定长度的线程池，即线程池的规模有上限。</br>
newCachedThreadPool：可缓存的线程池，如果线程池的当前规模超过了处理需求时，将回收空闲的线程，而当需求增加时，则可以添加新的线程，注意线程池的规模不存在任何限制。</br>
newSingleThreadExecutor:单线程的Executor，通过创建单个工作者线程来串行的执行任务，如果此线程异常结束，Executor会创建另一个线程来代替。注意此模式能确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。</br>
newScheduledThreadPool:创建固定长度的线程池，而且以延迟或者定时的方式来执行任务。</br>

（5）Executor的生命周期</br>
newXXXThreadPool都是返回的ExecutorService</br>

ExecutorService的生命周期主要有三种状态：运行、关闭和已终止。</br>

为了解决执行服务的生命周期问题，ExecutorService扩展了Executor接口，添加了管理生命周期的方法。</br>

shutdown：关闭线程池，不再接受新任务，等待已经提交的任务完成</br>
shutdownNow：强制立即关闭线程池，返回的等待执行的任务列表，执行中的任务抛出中断异常</br>
isShutdown：是否处于正在关闭状态</br>
isTerminated：是否结束</br>
awaitTerminated：阻塞等待关闭完成</br>


（6）延迟任务与周期任务</br>
通过ScheduledThreadPoolExecutor来代替Timer,TimerTask。</br>

Timer基于绝对时间，ScheduledThreadPoolExecutor基于相对时间。</br>
Timer执行所有定时任务只能创建一个线程，若某个任务执行时间过长，容易破坏其他TimerTask的定时精确性。</br>
Timer不捕获异常，Timetask抛出未检查的异常会终止定时器线程，已经调度但未执行的TimerTask将不会再执行，新的任务也不会被调度，出现"线程泄漏"</br>

<h2>3.找出可利用的并行性</h2>

（1）携带结果的任务Callable与Future</br>
Runnable的缺陷：不能返回一个值，或抛出一个异常</br>

Callable和Runnable都描述抽象的计算任务，Callable可以返回一个值，并可以抛出一个异常</br>

Executor执行任务的4个生命周期：创建，提交，开始，完成。Executor框架中，可以取消已提交但未开始执行的任务，对于已经开始执行的任务，只能当他们能响应中断时，才能取消，取消已经完成的任务不会有影响。</br>

Future表示了一个任务的生命周期，提供了相应的方法判断是否完成或被取消以及获取执行结果</br>

get方法：若任务完成，返回结果或抛出ExecutionException；若任务取消，抛出CancellationException；若任务没完成，阻塞等待结果</br>
ExecutorService的submit方法提交一个Callable任务，并返回一个Future来判断执行状态并获取执行结果
安全发布过程：将任务从提交线程到执行线程，结果从计算线程到调用get方法的线程</br>


（2）异构任务并行化中存在的局限：当异构任务之间的执行效率悬殊很大时，对于整体的性能提升来看并不是很有效。</br>


（3）完成服务CompletionService（Executor+BlockingQueue）</br>

　　使用BlockingQueue保存计算结果（Future)，使用take和poll获取，计算部分同样委托给Executor</br>

（4）为任务设定时限：如果超出期望执行时间，将不要其结果</br>




<h1>第七章  取消与关闭</h1>

<h2>1.终止与中断</h2>
Java没有提供任何机制来安全地终止线程（虽然Thread.stop和suspend方法提供了这样的机制，但由于存在缺陷，因此应该避免使用。 </br>

中断：一种协作机制，能够使一个线程终止另一个线程的当前工作立即停止会使共享的数据结构处于不一致的状态，需要停止时，发出中断请求，被要求中断的线程处理完他当前的任务后会自己判断是否停下来 。</br>

<h2>2.任务取消</h2>
若外部代码能在某个操作正常完成之前将其置入“完成”状态，则还操作是可取消的。（用户请求取消、有时间限制的操作<并发查找结果，一个线程找到后可取消其他线程>、应用程序事件、错误、关闭）。</br>

取消策略：详细地定义取消操作的“How”、“When”以及“What”，即其他代码如何（How）请求取消该任务，任务在何时（When）检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（What）操作。</br>


（1）中断</br>
线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。（在取消之外的其他操作使用中断都是不合适）。</br>

调用interrupt并不意味者立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。会在下一个取消点中断自己，如wait, sleep,join等。</br>

阻塞库方法，例如Thread.sleep和Object.wait等，都会检查线程何时中断，并且在发现时提前返回。它们在响应中断时执行的操作包括 :</br> 清除中断状态，抛出InterruptedException，表示阻塞操作由于中断而提前结束。</br>


显式的检测中断!Thread.currentThread().isInterrupted()后退出。</br>
阻塞方法中抓到InterruptedException后退出。</br>


（2）中断策略</br>
规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作。</br>
由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</br>


 (3) 响应中断</br>
传递异常（throws InterruptedException）</br>

恢复中断状态，从而事调用栈的上层代码能够对其进行处理。（Thread.currentThread().interrupt();）</br>


(4)通过Future实现取消</br>
     boolean cancel(boolean mayInterruptIfRunning);</br>

     如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败，返回false
     调用cancel时，如果调用成功，而此任务尚未启动，则此任务将永不运行
     如果任务已经执行，mayInterruptIfRunning参数决定了是否向执行任务的线程发出interrupt操作

(5)处理不可中断的阻塞</br>
       对于某些阻塞操作，只是设置了中断状态</br>

       Java.io包中的同步Socket I/O。虽然InputStream和OutputStream中的read和write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出一个SocketException。

       Java.io包中的同步I/O。当中断一个正在InterruptibleChannel上等待的线程时，将抛出ClosedByInterruptedException）并关闭链路（这还会使得其他在这条链路上阻塞的线程同样抛出ClosedByInterruptException）。当关闭一个InterruptibleChannel时，将导致所有在链路操作上阻塞的线程抛出AsynchronousCloseException。大多数标准的Channel都实现了InterruptibleChannel。

      Selector的异步I/O。如果一个线程在调用Selector.select方法（在java.nio.channels中）时阻塞了，那么调用close或wakeup方法会使线程抛出ClosedSelectorException并提前返回。

      获取某个锁。如果一个线程由于等待某个内置锁而被阻塞，那么将无法响应中断，因为线程认为它肯定获得锁，所以将不会理会中断请求。但是，在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</br>

（6）采用newTaskFor来封装非标准的取消</br>

<h2>2.停止基于线程的服务</h2>
（1）应用程序通常会创建基于线程的服务，如线程池。这些服务的时间一般比创建它的方法更长。</br>

    服务退出 -> 线程需要结束  无法通过抢占式的方法来停止线程，因此它们需要自行结束
    除非拥有某个线程，否则不能对该线程进行操控。例如，中断线程或者修改线程的优先级等
    线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池
    应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序不能拥有工作者线程，因此应用程序    不能直接停止工作者线程。
    
（2）服务应该用生命周期方法关闭它自己以及他拥有的线程</br>
         要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</br>
         ExecutorService提供的shutdown(), shutdownNow()</br>
         
（3）关闭ExecutorService</br>
    shutdown()：启动一次顺序关闭，执行完以前提交的任务，没有执行完的任务继续执行完。</br>
    shutdownNow()：试图停止所有正在执行的任务（向它们发出interrupt操作语法，无法保证能够停止正在处理的任务线程，但是会尽力尝试），并暂停处理正在等待的任务，并返回等待执行的任务列表。</br>
    ExecutorService已关闭，再向它提交任务时会抛RejectedExecutionException异常。</br>
    
（4）“毒丸”对象——当得到这个对象时，立即停止</br>
在提交“毒丸”对象之前提交的所有工作都会被处理，而生产者在提交了“毒丸”对象后，将不会再提交任何工作。</br>

（5）只执行一次的服务</br>
　如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一次私有的Executor来简化服务的生命周期管理，其中该Executor的生命周期是由这个方法来控制的。</br>
　
（6）shutdown的局限性</br>

我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。</br>




<h2>3.处理非正常的线程终止</h2>
在一个线程中启动另一个线程，另一个线程中抛出异常，如果没有捕获它，这个异常也不会传递到父线程中。</br>

任何代码都可能抛出一个RuntimeException。每当调用另一个方法时，都要对它的行为保持怀疑，不要盲目地认为它一定会正常返回，或者一定会抛出在方法原型中声明的某个已检查异常。</br>

未捕获异常的线程</br>
在Thread API中提供了UncaughtExceptionHandler，它能检测出某个线程由于未捕获的异常而终结的情况。</br>

在运行时间较长的应用程序中，通常会为所有的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。</br>


<h2>4.JVM关闭</h2>
JVM既可通过正常手段来关闭，也可强行关闭。</br>
正常关闭：当最后一个“正常（非守护）”线程结束时、当有人调用了System.exit时、或者通过其他特定于平台的方法关闭时。</br>
强行关闭：Runtime.halt，这种强行关闭方式将无法保证是否将运行关闭钩子。</br>

（1）关闭钩子
关闭钩子是指通过Runnable.addShutdownHook注册的但尚未开始的线程。</br>
JVM并不能保证关闭钩子的调用顺序。</br>
当所有的关闭钩子都执行结束时，如果runFinalizersOnExit为true，那么JVM将运行终结器（finalize），然后再停止。</br>
JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。当被强行关闭时，只是关闭JVM，而不会运行关闭钩子。</br>
关闭钩子应该是线程安全的。</br>
关闭钩子必须尽快退出，因为它们会延迟JVM的结束时间。</br>

（2）守护线程——一个线程来执行一些辅助工作，但有不希望这个线程阻碍JVM的关闭</br>
      线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程<。/br>
　  　普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将被抛弃——既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。</br>
　  　
（3）终结器（清理文件句柄或套接字句柄等）——避免使用</br>
 垃圾回收器对那些定义了finalize方法的对象会进行特殊处理：在回收器释放它们后，调用它们的finalize方法，从而确保一些持久化的资源被释放。</br>

　　通过使用finally代码块和显式的close方法，能够比使用终结器更好地管理资源。例外：当需要管理对象时，并且该对象持有的资源是通过本地方法获得的。</br>
　　
　　
　　
　　
　　
　　
　　
　　
　　
<h1>第八章  线程池的使用</h1>
<h2>1.在任务和执行策略间隐性耦合</h2>
Executor框架将任务的提交和它的执行策略解耦开来。虽然Executor框架为制定和修改执行策略提供了相当大的灵活性，但并非所有的任务都能适用所有的执行策略。</br>

     依赖性任务：依赖其他同步任务的结果，使其不得不顺序执行，影响活跃性。
     使用线程封闭的任务：在单线程的Executor中执行，任务可以不是线程安全的，但是一旦提交到线程池时，就会失去线程安全。
     对响应时间敏感的任务：在单个线程或含有少量线程的线程池中执行是不可接受的。
     使用ThreadLocal的任务：ThreadLocal使每个线程都可以拥有某个变量的一个私有"版本"，而线程池中的线程是重复使用的，即一次使用完后，会被重新放回线程池，可被重新分配使用。因此，ThreadLocal线程变量，如果保存的信息只是针对一次请求的，放回线程池之前需要清空这些Threadlocal变量的值（或者取得线程之后，首先清空这些Threadlocal变量的值）。
     只有任务都是同类型并且相互独立时，线程池的效率达到最佳。


（1）线程饥饿死锁</br>
    在线程池中所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞。</br>
例1：在单线程池中，正在执行的任务阻塞等待队列中的某个任务执行完毕。</br>

例2：线程池不够大时，通过栅栏机制协调多个任务时。</br></br>

例3：由于其他资源的隐性限制，每个任务都需要使用有限的数据库连接资源，那么不管线程池多大，都会表现出和和连接资源相同的大小。　</br>

每当提交了一个有依赖性的Executor任务时，要清楚地知道可能会出现线程"饥饿"死锁，因此需要在代码或配置Executor地配置文件中记录线程池大小限制或配置限制。</br>


（2）运行时间较长的任务</br>
线程池的大小应该超过有较长执行时间的任务数量，否则可能造成线程池中线程均服务于长时间任务导致其它短时间任务也阻塞导致性能下降</br>

缓解策略：限定任务等待资源的时间，如果等待超时，那么可以把任务标示为失败，然后中止任务或者将任务重新返回队列中以便随后执行。这样，无论任务的最终结果是否成功，这种方法都能确保任务总能继续执行下去，并将线程释放出来以执行一些能更快完成的任务。例如Thread.join、BlockingQueue.put、CountDownLatch.await以及Selector.select等</br>


<h2>2.设置线程池的大小</h2>
线程池的理想大小取决于被提交任务的类型及所部署系统的特性</br>

线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源</br>
如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐量</br>
对于计算密集型的任务，在拥有Ncpu个处理器的系统上，当线程池的大小为Ncpu+1时，通常能实现最优的利用率；对于包含I/O操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大</br>

N(threads)=N(cpu)*U(cpu)*(1+W/C)  </br> N(cpu)=CPU的数量=Runtime.getRuntime().availableProcessors(); U(cpu)= 期望CPU的使用率，0<=U(cpu)<=1 ；W/C=等待时间与运行时间的比率</br>



<h2>3.配置ThreadPoolExecutor</h2>
（1）线程的创建与销毁</br>

CorePoolSize: 线程池基本大小，在创建ThreadPoolExecutor初期，线程并不会立即启动，而是等到有任务提交时才会启动，除非调用prestartAllCoreThreads，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。</br>
MaxmumPooSize: 线程池最大大小表示可同时活动的线程数量的上限。若某个线程的空闲时间超过了keepAliveTime, 则被标记为可回收的
newFixedThreadPool: CorePoolSize = MaxmumPoolSize</br>

newCachedThreadPool: CorePoolSize=0，MaxmumPoolSize=Integer.MAX_VALUE，线程池可被无限扩展，需求降低时自动回收</br>


（2）管理队列任务</br>
workQueue：用于保存超过线程池线程处理速率的Runnable任务的队列 （三种：无界队列、有界队列和同步移交）
newFixedThreadPool和newSingleThreadPool在默认情况下将使用一个无界的LinkedBlockingQueue，有更好的性能。</br>

使用有界队列有助于避免资源耗尽的情况发生，为了避免当队列填满后，在使用有界的工作队列时，队列的大小与线程池的大小必须一起调节，能防止过载。</br>

对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队，要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接受这个元素，任务会直接移交给执行它的线程，否则将拒绝任务。newCachedThreadPool工厂方法中就使用了SynchronousQueue。</br>

使用优先队列PriorityBlockingQueue可以控制任务被执行的顺序。</br>



（3）饱和策略</br>

AbortPolicy(中止策略)，默认的饱和策略。会抛出RejectedExecutionException异常（抛弃当前任务vs抛弃最旧任务）</br>
调用者运行：下一个任务在调用了execute方法的主线程中进行运行，主线程至少在一段时间内不能提交任何任务。到达的请求将被保存在TCP层的队列中而不是在应用程序的队列中，导致服务器在高负载下实现一种平缓的性能降低</br>
其他：对执行策略进行修改，使用信号量，控制处于执行中的任务</br>


（4）线程工厂</br>

通过自定义线程工厂可以对其进行扩展加入新的功能实现。</br>

当应用需要利用安全策略来控制某些特殊代码库的访问权，可以利用PrivilegedThreadFactory来定制自己的线程工厂，以免出现安全性异常。将与创建privilegedThreadFactory的线程拥有相同的访问权限、AccessControlContext和contextClassLoader。</br>


（5）在调用构造函数后在定制ThreadPoolExecutor</br>

可以在创建线程池后，再通过Setter方法设置其基本属性（将ExecutorService扩展为ThreadPoolExecutor。）</br>
在Executors中包含一个unconfigurableExecutorService工厂方法，该方法对一个现有的ExecutorService进行包装，使其只暴露出ExecutorService的方法，因此不能对它进行配置。</br>




<h2>4.扩展ThreadPoolExecutor</h2>
ThreadPoolExecutor使用了模板方法模式，提供了beforeExecute、afterExecute和terminated扩展方法。</br>


线程执行前调用beforeExecute（如果beforeExecute抛出了一个RuntimeException，那么任务将不会被执行）。</br>

线程执行后调用afterExecute（抛出异常也会调用，如果任务在完成后带有一个Error，那么就不会调用afterExecute）。</br>

在线程池完成关闭操作时调用terminated，也就是所有任务都已经完成并且所有工作者线程也已经关闭后。</br>



<h2>5.递归算法的并行化</h2>
如果循环中的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成再继续执行，那么就可以使用Executor将串行循环转化为并行循环</br>

如果需要提交一个任务集并等待它们完成，那么可以使用ExecutorService.invokeAll</br>

如果递归执行的任务中，在每个迭代操作中都不需要来自于后续递归迭代的结果，可以创建一个特定于遍历过程的Executor，并使用shutdown和awaitTermination等方法，等待上面并行运行的结果</br>