# Java虚拟机

标签（空格分隔）： java 虚拟机

---

<h2>1.内存泄露和内存溢出的区别</h2>
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</br>
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</br>

以发生的方式来分类，内存泄漏可以分为4类： </br>

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </br>
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </br>
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。</br> 
4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 </br>


<h2>Java内存模型及各个区域简介</h2>
1.程序计数器</br>
可以看做当前线程所执行的字节码的行号指示器，字节码解释器通过改变计数器的值取下一条需要执行的字节码指令</br>
每条线程都有自己独立的程序计数器，各线程计数器互不影响，独立存储。</br>
如果执行的是java方法，计数器存的是正在执行的虚拟机字节码指令地址；如果执行的是native方法，则计数器为空</br>

2.Java虚拟机栈</br>
每个Java方法执行时都会创建一个栈帧：局部变量表，操作数栈，动态链接，方法接口</br>
局部变量表：存放编译器克制的各种基本数据类型、对象引用、returnaddress类型</br>
运行时不会改变局部变量的大小</br>
两种异常：线程请求的栈深度大于虚拟机所允许的长度，将抛出StackOverflowError异常；扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</br>

3.本地方法栈</br>
与Java虚拟机栈类似，只不过本地方法栈为虚拟机使用到的native方法服务</br>

4.Java堆</br>
Java堆是被所有线程共享的一块区域，唯一的目的就是存放对象实例。</br>
Java堆是垃圾收集器的主要区域，因此很多时候也被称为“GC堆”（垃圾堆，哈哈哈）</br>
Java可以处于物理上不连续的空间，只要逻辑连续即可，如果在堆内没有内存完成实例分配，将会抛出OutOfMemoryError异常</br>

5.方法区</br>
和Java堆一样，是被所有线程共享的一块区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</br>
如果在方法区内没有满足内存分配需求，将会抛出OutOfMemoryError异常</br>

6.运行时常量池
是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。</br>
运行期间也可能将新的常量放入运行时常量池（String.intern()）</br>
如果常量池没有满足内存分配需求，将会抛出OutOfMemoryError异常</br>

7.直接内存（堆外内存）</br>
堆外内存，其实就是不受JVM控制的内存。相比于堆内内存有几个优势： </br>
1 减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作（可能使用多线程或者时间片的方式，根本感觉不到） </br>
2 加快了复制的速度。因为堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。 </br>
而福之祸所依，自然也有不好的一面： </br>
1 堆外内存难以控制，如果内存泄漏，那么很难排查 </br>
2 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</br>




<h2>3.对象的内存布局和访问定位</h2>
1.对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。</br>
2.对象头第一部分用于对象自身的运行时数据；第二部分是类型指针，通过类型指针确定对象是哪个类的实例；如果对象是个Java数组，对象头中还需要有一块记录数组长度的数据</br>
3.实例数据部分是对象真正存储的有效信息</br>
4.对齐填充将对象大小填充成8字节的整数倍</br>

5.对象访问定位通过虚拟机栈的reference操作对象的具体对象</br>
6.对象访问定位有两种方式：句柄（垃圾收集只改变句柄指针，不改变reference），直接指针（速度更快）</br>



<h2>4.OutOfMemory异常测试</h2>
1.Java堆溢出（不停的创建新的对象实例）</br>
2.虚拟机栈和本地方法栈溢出（不停地创建新线程）</br>
3.运行时常量池溢出（使用String.intern(）方法不停创建新的字符串常量）</br>
4.方法区溢出（借助CGlib创建动态类）</br>
5.本机直接内存溢出（使用unsafe分配本机内存）</br>







